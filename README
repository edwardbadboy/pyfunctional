Usage:
./tranToken testCase.py | python


Explaination:
Python is very interesting. It's very easy to write language extensions for it. Actually I wrote a currying and function composing extension. It works like this:

def f1(x):
    return x * 2

def f2(x):
    return x + 2

def f3(x):
    return x ** 2

print f3(f2(f1(3)))  # will print 64
F = (fcp() * f3 * f2 * f1)
print F(3)  # will print 64

So fcp is a function composition(函数复合 in Chineses) class I wrote for Python. "fcp() * f3 * f2 * ..." will result series of function compositions. In the code, the result composition function is called immediately, but in fact you can assign it to a variable and pass to "map", "filter" or other high order functions.


Currying(科里化 in Chinese) can make function composition more interesting. Currying is the advanced version of "partial" in functools module. Consider this one:

from operator import add, mul
F = fcp() * $mul(2) * $add(1)
print F(2)

Here "$" is the language extension I add to Python. "$mul(2)" means the same as "partial(mul ,2)", so "fcp() * $mul(2) * $add(1)" means "partial (mul ,2 )(partial (add ,1 ))".
So "F(2)" really means "2 * (1 + 2)". Sounds wired but it's really useful, because you can pass "F" everywhere as a normal function, this means you can construct some logic dynamically and pass it to another part of the program, interesting, right?

Here comes the most interesting one. Consider we want to find odd square numbers that less than 100. Using currying and function composition, we can write the code like this;

from itertools import count as icount
from itertools import imap, ifilter, takewhile
from operator import pow, gt

def isOdd(x):
    return (x % 2) != 0

def flip(f):
    return lambda a, b: f(b, a)

R = fcp() * $takewhile($gt(100)) * $ifilter(isOdd) * $imap($(flip(pow))(2)) * icount

for i in R(1):
    print i

Here "flip" is to return a function that take the parameters reversely from the original function.
"icount(x)" gives an infinite generator counting x, x+1, ....
"imap(fun, iter)" works like map, but uses generators.
"ifilter(fun, iter)" works like filter, but uses generators.
"itakewhile(fun, iter)" returns prefix of series of items generated by iter when fun(item) is true.
So, "$takewhile($gt(100)) " is a function which takes a sequence then yield first ones of elements while elements < 100.
"$ifilter(isOdd)" is a function filters odd elements from a sequence.
"$(flip(pow))(2)" is a function which returns the square of the argument.
"$imap($(flip(pow))(2)) " is a function takes a sequence an squares all the elements.
Then we compose them using "fcp() *" and get a new function "R".

Becareful, calling "for i in R(1):" will take 1 element each time, the whole function chain will calculate for this result then pause to wait the next round. They will not compute all the results then pass to the next function in the chain. If they do, the chain can not stop, because icount is infinite. So the chain is lazy, it will just compute things as much as you need them, no more, no less. Yes, lazy evaluation is its scientific name. Using this technique, you can describe and process infinite data structures. List comprehension can get the same result and more readable, but it's not lazy, so it will not stop and burns your cpu to the end of universe. We can use generator expressions instead to get the same result, but function composition and currying can be used in a wide range area when you program.
